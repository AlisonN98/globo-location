<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Travel Globe</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
        }
        
        #globe-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            color: white;
        }
        
        #controls h3 {
            margin-top: 0;
            color: #4CAF50;
        }
        
        .control-group {
            margin-bottom: 10px;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        
        button:hover {
            background: #45a049;
        }
        
        input[type="file"] {
            margin: 5px;
        }
        
        #photo-gallery {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 10px;
            color: white;
            max-width: 300px;
            display: none;
        }
        
        .photo-item {
            margin: 10px 0;
            text-align: center;
        }
        
        .photo-item img {
            max-width: 100%;
            height: auto;
            border-radius: 5px;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            z-index: 200;
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="globe-container">
        <div id="loading">Loading 3D Globe...</div>
        
        <div id="controls">
            <h3>Travel Globe Controls</h3>
            <div class="control-group">
                <label>Add City:</label>
                <input type="text" id="city-name" placeholder="Type a city (e.g. Paris)">
                <button onclick="addCity()">Add City</button>
            </div>
            <div class="control-group">
                <label>Upload Photos:</label>
                <input type="file" id="photo-upload" accept="image/*" multiple>
                <button onclick="uploadPhotos()">Upload to Selected Location</button>
            </div>
            <div class="control-group">
                <button onclick="clearAllLocations()">Clear All Locations</button>
            </div>
        </div>
        
        <div id="photo-gallery">
            <h3 id="gallery-title">Photos</h3>
            <div id="gallery-content"></div>
            <div style="display:flex; gap:8px; justify-content:flex-end; margin-top:8px;">
                <button onclick="removeSelectedLocation()" style="background:#f44336;">Remove Location</button>
                <button onclick="closeGallery()">Close</button>
            </div>
        </div>
        
        <div id="instructions">
            Mouse: Drag to rotate | Scroll to zoom | Click markers to view photos | Add cities by name
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let globe, earthMaterial, cloudMesh, atmosphereMesh;
        let locations = [];
        let locationMarkers = [];
        let travelLines = [];
        let selectedLocationIndex = -1;
        let nominatimAbortController = null;
        
        // Initialize the 3D scene
        function init() {
            // Create scene
            scene = new THREE.Scene();
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 3);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000);
            document.getElementById('globe-container').appendChild(renderer.domElement);
            
            // Add controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 1.5;
            controls.maxDistance = 10;
            
            // Create space environment
            createSpaceEnvironment();
            
            // Create Earth globe
            createGlobe();
            
            // Load saved data
            loadSavedData();
            
            // Start animation loop
            animate();
            
            // Hide loading screen
            document.getElementById('loading').style.display = 'none';
        }
        
        // Create space environment with stars, sun, and moon
        function createSpaceEnvironment() {
            // Create starfield
            const starGeometry = new THREE.BufferGeometry();
            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.5,
                transparent: true,
                opacity: 0.8
            });
            
            const starVertices = [];
            for (let i = 0; i < 10000; i++) {
                const x = (Math.random() - 0.5) * 2000;
                const y = (Math.random() - 0.5) * 2000;
                const z = (Math.random() - 0.5) * 2000;
                starVertices.push(x, y, z);
            }
            
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            const starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);
            
            // Create sun
            const sunGeometry = new THREE.SphereGeometry(0.3, 32, 32);
            const sunMaterial = new THREE.MeshBasicMaterial({
                color: 0xffaa00,
                emissive: 0xff4400
            });
            const sun = new THREE.Mesh(sunGeometry, sunMaterial);
            sun.position.set(8, 3, 0);
            scene.add(sun);
            
            // Create moon
            const moonGeometry = new THREE.SphereGeometry(0.15, 32, 32);
            const moonMaterial = new THREE.MeshBasicMaterial({
                color: 0xcccccc,
                emissive: 0x222222
            });
            const moon = new THREE.Mesh(moonGeometry, moonMaterial);
            moon.position.set(-6, 2, 0);
            scene.add(moon);
            
            // Add ambient lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
            scene.add(ambientLight);
            
            // Add directional light from sun
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.copy(sun.position);
            scene.add(directionalLight);
        }
        
        // Create the Earth globe with realistic textures and cloud layer
        function createGlobe() {
            const loader = new THREE.TextureLoader();
            const urls = {
                day: 'https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg',
                normal: 'https://threejs.org/examples/textures/planets/earth_normal_2048.jpg',
                specular: 'https://threejs.org/examples/textures/planets/earth_specular_2048.jpg',
                clouds: 'https://threejs.org/examples/textures/planets/earth_clouds_1024.png',
                night: 'https://threejs.org/examples/textures/planets/earth_lights_2048.png'
            };
            const textures = {};
            let remaining = 5;
            
            function onLoaded(key, tex) {
                tex.anisotropy = Math.min(8, renderer.capabilities.getMaxAnisotropy() || 1);
                textures[key] = tex;
                remaining--;
                if (remaining === 0) {
                    const globeGeometry = new THREE.SphereGeometry(1, 128, 128);
                    earthMaterial = new THREE.MeshPhongMaterial({
                        map: textures.day,
                        normalMap: textures.normal,
                        specularMap: textures.specular,
                        emissive: new THREE.Color(0x111111),
                        emissiveMap: textures.night,
                        specular: new THREE.Color(0x222222),
                        shininess: 15
                    });
                    globe = new THREE.Mesh(globeGeometry, earthMaterial);
                    scene.add(globe);
                    
                    // Atmosphere glow (additive, back side)
                    const atmosphereGeometry = new THREE.SphereGeometry(1.02, 128, 128);
                    const atmosphereMaterial = new THREE.ShaderMaterial({
                        uniforms: {
                            c: { value: 0.5 },
                            p: { value: 3.0 },
                            glowColor: { value: new THREE.Color(0x50a7ff) },
                            viewVector: { value: camera.position }
                        },
                        vertexShader: `
                            uniform vec3 viewVector;
                            uniform float c;
                            uniform float p;
                            varying float intensity;
                            void main() {
                                vec3 vNormal = normalize(normalMatrix * normal);
                                vec3 vNormel = normalize(normalMatrix * viewVector - (modelViewMatrix * vec4(position, 1.0)).xyz);
                                intensity = pow(c - dot(vNormal, vNormel), p);
                                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                            }
                        `,
                        fragmentShader: `
                            uniform vec3 glowColor;
                            varying float intensity;
                            void main() {
                                gl_FragColor = vec4(glowColor, 1.0) * intensity;
                            }
                        `,
                        side: THREE.BackSide,
                        blending: THREE.AdditiveBlending,
                        transparent: true,
                        depthWrite: false
                    });
                    atmosphereMesh = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
                    scene.add(atmosphereMesh);
                    
                    // Cloud layer
                    const cloudGeometry = new THREE.SphereGeometry(1.01, 128, 128);
                    const cloudMaterial = new THREE.MeshPhongMaterial({
                        map: textures.clouds,
                        transparent: true,
                        depthWrite: false,
                        opacity: 0.8
                    });
                    cloudMesh = new THREE.Mesh(cloudGeometry, cloudMaterial);
                    scene.add(cloudMesh);
                }
            }
            
            loader.load(urls.day, tex => onLoaded('day', tex));
            loader.load(urls.normal, tex => onLoaded('normal', tex));
            loader.load(urls.specular, tex => onLoaded('specular', tex));
            loader.load(urls.clouds, tex => onLoaded('clouds', tex));
            loader.load(urls.night, tex => onLoaded('night', tex));
        }
        
        // Convert lat/lng to 3D coordinates on sphere
        function latLngToVector3(lat, lng, radius = 1.02) {
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lng + 180) * (Math.PI / 180);
            
            const x = -(radius * Math.sin(phi) * Math.cos(theta));
            const z = (radius * Math.sin(phi) * Math.sin(theta));
            const y = (radius * Math.cos(phi));
            
            return new THREE.Vector3(x, y, z);
        }
        
        // Add a city by name using OpenStreetMap Nominatim
        async function addCity() {
            const input = document.getElementById('city-name');
            const query = (input.value || '').trim();
            if (!query) {
                alert('Type a city name');
                input.focus();
                return;
            }
            try {
                // cancel prior request if any
                if (nominatimAbortController) {
                    nominatimAbortController.abort();
                }
                nominatimAbortController = new AbortController();
                const url = `https://nominatim.openstreetmap.org/search?format=jsonv2&limit=1&q=${encodeURIComponent(query)}`;
                const res = await fetch(url, {
                    headers: {
                        'Accept': 'application/json',
                        'User-Agent': 'TravelGlobe/1.0 (contact: example@example.com)'
                    },
                    signal: nominatimAbortController.signal,
                    method: 'GET',
                    mode: 'cors',
                    cache: 'no-store'
                });
                if (!res.ok) throw new Error('Geocoding failed');
                const data = await res.json();
                if (!Array.isArray(data) || data.length === 0) {
                    alert('City not found');
                    return;
                }
                const best = data[0];
                const lat = parseFloat(best.lat);
                const lng = parseFloat(best.lon);
                const displayName = best.display_name || query;
                if (isNaN(lat) || isNaN(lng)) {
                    alert('Invalid coordinates from geocoder');
                    return;
                }
                const location = {
                    name: displayName,
                    lat: lat,
                    lng: lng,
                    photos: []
                };
                locations.push(location);
                createLocationMarker(location, locations.length - 1);
                saveData();
                updateTravelLines();
                input.value = '';
            } catch (err) {
                if (err.name === 'AbortError') return;
                console.error(err);
                alert('Error searching city. Try again.');
            }
        }
        
        // Create a visual marker for a location
        function createLocationMarker(location, index) {
            const position = latLngToVector3(location.lat, location.lng);
            
            // Create marker geometry (small sphere)
            const markerGeometry = new THREE.SphereGeometry(0.02, 16, 16);
            const markerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            marker.position.copy(position);
            marker.userData = { locationIndex: index };
            
            // Create line pointing outward
            const lineGeometry = new THREE.BufferGeometry();
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
            const outwardPosition = position.clone().multiplyScalar(1.1);
            
            const linePositions = [
                position.x, position.y, position.z,
                outwardPosition.x, outwardPosition.y, outwardPosition.z
            ];
            
            lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(linePositions, 3));
            const line = new THREE.Line(lineGeometry, lineMaterial);
            
            // Create group to hold marker and line
            const markerGroup = new THREE.Group();
            markerGroup.add(marker);
            markerGroup.add(line);
            markerGroup.userData = { locationIndex: index };
            
            // Add click event
            markerGroup.traverse((child) => {
                if (child.isMesh) {
                    child.userData = { locationIndex: index };
                }
            });
            
            if (globe) {
                globe.add(markerGroup);
            } else {
                scene.add(markerGroup);
            }
            locationMarkers.push(markerGroup);
        }
        
        // Update travel lines between locations
        function updateTravelLines() {
            // Remove existing travel lines and do not create new ones (feature disabled)
            travelLines.forEach(line => {
                if (globe) {
                    globe.remove(line);
                } else {
                    scene.remove(line);
                }
            });
            travelLines = [];
            return;
        }
        
        // Upload photos to selected location
        function uploadPhotos() {
            const fileInput = document.getElementById('photo-upload');
            const files = fileInput.files;
            
            if (selectedLocationIndex === -1) {
                alert('Please select a location first by clicking on a marker');
                return;
            }
            
            if (files.length === 0) {
                alert('Please select photos to upload');
                return;
            }
            
            Array.from(files).forEach(file => {
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        locations[selectedLocationIndex].photos.push({
                            name: file.name,
                            data: e.target.result,
                            date: new Date().toISOString()
                        });
                        saveData();
                    };
                    reader.readAsDataURL(file);
                }
            });
            
            alert(`Uploaded ${files.length} photos to ${locations[selectedLocationIndex].name}`);
            fileInput.value = '';
        }
        
        // Handle mouse clicks for location selection
        function onMouseClick(event) {
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects(locationMarkers, true);
            
            if (intersects.length > 0) {
                const locationIndex = intersects[0].object.userData.locationIndex;
                selectedLocationIndex = locationIndex;
                showPhotoGallery(locationIndex);
            }
        }
        
        // Show photo gallery for a location
        function showPhotoGallery(locationIndex) {
            const location = locations[locationIndex];
            const gallery = document.getElementById('photo-gallery');
            const title = document.getElementById('gallery-title');
            const content = document.getElementById('gallery-content');
            
            title.textContent = `Photos from ${location.name}`;
            content.innerHTML = '';
            
            if (location.photos.length === 0) {
                content.innerHTML = '<p>No photos uploaded yet.</p>';
            } else {
                location.photos.forEach(photo => {
                    const photoDiv = document.createElement('div');
                    photoDiv.className = 'photo-item';
                    photoDiv.innerHTML = `
                        <img src="${photo.data}" alt="${photo.name}">
                        <p>${photo.name}</p>
                    `;
                    content.appendChild(photoDiv);
                });
            }
            
            gallery.style.display = 'block';
        }
        
        // Close photo gallery
        function closeGallery() {
            document.getElementById('photo-gallery').style.display = 'none';
            selectedLocationIndex = -1;
        }

        // Remove currently selected location
        function removeSelectedLocation() {
            if (selectedLocationIndex === -1) return;
            const location = locations[selectedLocationIndex];
            if (!confirm(`Remove location: ${location.name}?`)) return;
            // Remove marker group from scene/globe
            const markerGroup = locationMarkers[selectedLocationIndex];
            if (markerGroup) {
                if (globe && markerGroup.parent === globe) {
                    globe.remove(markerGroup);
                } else {
                    scene.remove(markerGroup);
                }
            }
            // Remove from arrays
            locations.splice(selectedLocationIndex, 1);
            locationMarkers.splice(selectedLocationIndex, 1);
            // Reindex userData for remaining markers
            locationMarkers.forEach((group, idx) => {
                group.userData.locationIndex = idx;
                group.traverse(child => {
                    if (child.userData) child.userData.locationIndex = idx;
                });
            });
            saveData();
            updateTravelLines();
            closeGallery();
        }
        
        // Clear all locations
        function clearAllLocations() {
            if (confirm('Are you sure you want to clear all locations and photos?')) {
                locations = [];
                locationMarkers.forEach(marker => {
                    if (globe && marker.parent === globe) {
                        globe.remove(marker);
                    } else {
                        scene.remove(marker);
                    }
                });
                locationMarkers = [];
                travelLines.forEach(line => {
                    if (globe && line.parent === globe) {
                        globe.remove(line);
                    } else {
                        scene.remove(line);
                    }
                });
                travelLines = [];
                selectedLocationIndex = -1;
                closeGallery();
                saveData();
            }
        }
        
        // Save data to localStorage
        function saveData() {
            localStorage.setItem('globeTravelData', JSON.stringify(locations));
        }
        
        // Load saved data from localStorage
        function loadSavedData() {
            const savedData = localStorage.getItem('globeTravelData');
            if (savedData) {
                locations = JSON.parse(savedData);
                locations.forEach((location, index) => {
                    createLocationMarker(location, index);
                });
                updateTravelLines();
            }
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            if (globe) globe.rotation.y += 0.0002;
            if (cloudMesh) cloudMesh.rotation.y += 0.0004;
            if (atmosphereMesh) atmosphereMesh.rotation.y += 0.0002;
            renderer.render(scene, camera);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Add click event listener
        window.addEventListener('click', onMouseClick);
        // Enter key triggers addCity
        window.addEventListener('keydown', (e) => {
            const active = document.activeElement;
            if (e.key === 'Enter' && active && active.id === 'city-name') {
                e.preventDefault();
                addCity();
            }
        });
        
        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
